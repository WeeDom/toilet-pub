````markdown
# Story 1.5: Remote Firmware Update Infrastructure

**Epic:** 1 - Infrastructure Enhancement
**Status:** ❌ TODO

## Description
Build a comprehensive Over-The-Air (OTA) firmware update infrastructure enabling remote ESP32-CAM updates across multiple sites without physical access. Architecture uses EC2 as command & control center, SSH tunnels through Raspberry Pi gateways, and local OTA servers for reliable firmware deployment. Ansible orchestrates multi-site updates with rollback capabilities.

## Goals
- Remote firmware updates for ESP32-CAM devices
- No physical access required for updates
- EC2 as central Command & Control (CNC) server
- SSH tunnel from EC2 to Pi gateways (traverses NAT)
- Pi-based local OTA HTTP server for ESP32 devices
- Ansible-driven orchestration for multi-site deployments
- Staged rollout (test → staging → production)
- Automatic rollback on failed updates
- Firmware version tracking and audit logging
- Support for hundreds of devices across multiple sites

## Technical Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                         AWS EC2 (CNC)                          │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────────┐ │
│  │  Ansible     │  │  Firmware    │  │  Update Dashboard    │ │
│  │  Playbooks   │  │  Repository  │  │  (Web UI)            │ │
│  └──────┬───────┘  └──────┬───────┘  └──────────────────────┘ │
│         │                  │                                     │
└─────────┼──────────────────┼─────────────────────────────────────┘
          │ SSH Tunnel       │ HTTPS Download
          │ (persistent)     │
          ▼                  ▼
┌─────────────────────────────────────┐
│    Raspberry Pi Gateway (Site 1)    │
│  ┌──────────────────────────────┐   │
│  │  SSH Reverse Tunnel Client   │   │
│  │  Port forward: 8080 → EC2    │   │
│  └──────────────────────────────┘   │
│  ┌──────────────────────────────┐   │
│  │  OTA HTTP Server (Python)    │   │
│  │  Serves firmware to ESP32s   │   │
│  │  Port: 8888                   │   │
│  └──────┬───────────────────────┘   │
└─────────┼───────────────────────────┘
          │ HTTP (local network)
          ▼
    ┌─────────────────┐
    │  ESP32-CAM #1   │
    │  HTTP OTA       │
    └─────────────────┘
    ┌─────────────────┐
    │  ESP32-CAM #2   │
    │  HTTP OTA       │
    └─────────────────┘
    ┌─────────────────┐
    │  ESP32-CAM #N   │
    │  HTTP OTA       │
    └─────────────────┘
```

## Technical Implementation

### EC2 Command & Control Server

**File: `ec2/firmware_cnc/server.py`**
Flask-based CNC server for firmware management:

```python
from flask import Flask, request, render_template, jsonify
from ansible.playbook import PlayBook
import os
import logging

app = Flask(__name__)
app.config['FIRMWARE_DIR'] = '/opt/guard-e-loo/firmware'
app.config['ANSIBLE_DIR'] = '/opt/guard-e-loo/ansible'

@app.route('/api/firmware/upload', methods=['POST'])
def upload_firmware():
    """Upload new firmware binary"""
    file = request.files['firmware']
    version = request.form['version']

    # Save firmware
    firmware_path = f"{app.config['FIRMWARE_DIR']}/{version}.bin"
    file.save(firmware_path)

    # Update manifest
    update_firmware_manifest(version, firmware_path)

    return jsonify({'status': 'success', 'version': version})

@app.route('/api/firmware/deploy', methods=['POST'])
def deploy_firmware():
    """Trigger Ansible deployment to sites"""
    data = request.json
    version = data['version']
    sites = data['sites']  # ['site001', 'site002']
    strategy = data.get('strategy', 'rolling')  # 'rolling' or 'immediate'

    # Trigger Ansible playbook
    result = run_ansible_deployment(version, sites, strategy)

    return jsonify(result)

@app.route('/api/devices/status', methods=['GET'])
def device_status():
    """Get firmware status of all devices"""
    devices = get_device_inventory()
    return jsonify(devices)

@app.route('/dashboard')
def dashboard():
    """Web UI for firmware management"""
    return render_template('dashboard.html')

def run_ansible_deployment(version, sites, strategy):
    """Execute Ansible playbook for OTA deployment"""
    playbook_path = f"{app.config['ANSIBLE_DIR']}/playbooks/ota_deploy.yml"

    extra_vars = {
        'firmware_version': version,
        'target_sites': sites,
        'deployment_strategy': strategy
    }

    # Run Ansible playbook (via subprocess or ansible-runner)
    cmd = [
        'ansible-playbook',
        playbook_path,
        '-e', f"firmware_version={version}",
        '-e', f"target_sites={','.join(sites)}",
        '--limit', ','.join(sites)
    ]

    result = subprocess.run(cmd, capture_output=True, text=True)

    return {
        'success': result.returncode == 0,
        'output': result.stdout,
        'errors': result.stderr
    }

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, ssl_context='adhoc')
```

### SSH Reverse Tunnel Setup

**File: `pi_gateway/ota/tunnel_manager.py`**
Persistent SSH reverse tunnel from Pi to EC2:

```python
import subprocess
import time
import logging

class SSHTunnelManager:
    def __init__(self, ec2_host, ec2_user, local_port, remote_port):
        self.ec2_host = ec2_host
        self.ec2_user = ec2_user
        self.local_port = local_port
        self.remote_port = remote_port
        self.process = None

    def start_tunnel(self):
        """Start persistent SSH reverse tunnel to EC2"""
        cmd = [
            'ssh',
            '-N',  # No command execution
            '-R', f'{self.remote_port}:localhost:{self.local_port}',  # Reverse tunnel
            '-o', 'ServerAliveInterval=30',  # Keep-alive every 30s
            '-o', 'ServerAliveCountMax=3',
            '-o', 'ExitOnForwardFailure=yes',
            '-i', '/home/pi/.ssh/guard-e-loo-pi.key',
            f'{self.ec2_user}@{self.ec2_host}'
        ]

        self.process = subprocess.Popen(cmd)
        logging.info(f"SSH tunnel started: PID {self.process.pid}")

    def monitor_tunnel(self):
        """Monitor and restart tunnel if it dies"""
        while True:
            if self.process.poll() is not None:
                logging.warning("SSH tunnel died, restarting...")
                time.sleep(5)
                self.start_tunnel()
            time.sleep(30)

if __name__ == '__main__':
    tunnel = SSHTunnelManager(
        ec2_host='ec2-3-8-123-45.eu-west-2.compute.amazonaws.com',
        ec2_user='ubuntu',
        local_port=8888,  # Pi OTA server
        remote_port=8080  # EC2 forward port (site-specific)
    )
    tunnel.start_tunnel()
    tunnel.monitor_tunnel()
```

**File: `/etc/systemd/system/guard-e-loo-tunnel.service`**
Systemd service for persistent tunnel:

```ini
[Unit]
Description=Guard-e-loo SSH Tunnel to EC2
After=network.target

[Service]
Type=simple
User=pi
ExecStart=/usr/bin/python3 /home/pi/guard-e-loo/ota/tunnel_manager.py
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
```

### Pi-Based OTA HTTP Server

**File: `pi_gateway/ota/ota_server.py`**
Simple HTTP server for ESP32 OTA downloads:

```python
from http.server import HTTPServer, SimpleHTTPRequestHandler
import os
import logging
import json

class OTAHandler(SimpleHTTPRequestHandler):
    def do_GET(self):
        """Serve firmware binary to ESP32 devices"""
        if self.path == '/firmware.bin':
            # Serve current firmware version
            firmware_path = '/home/pi/guard-e-loo/ota/firmware/current.bin'

            if not os.path.exists(firmware_path):
                self.send_error(404, "Firmware not found")
                return

            # Log download attempt
            logging.info(f"OTA request from {self.client_address[0]}")

            # Serve binary
            self.send_response(200)
            self.send_header('Content-type', 'application/octet-stream')
            self.send_header('Content-Length', os.path.getsize(firmware_path))
            self.end_headers()

            with open(firmware_path, 'rb') as f:
                self.wfile.write(f.read())

        elif self.path == '/version':
            # Return current firmware version info
            version_info = get_current_version()

            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            self.wfile.write(json.dumps(version_info).encode())

        else:
            self.send_error(404)

def get_current_version():
    """Read firmware version from manifest"""
    manifest_path = '/home/pi/guard-e-loo/ota/firmware/manifest.json'
    with open(manifest_path) as f:
        return json.load(f)

if __name__ == '__main__':
    server_address = ('', 8888)
    httpd = HTTPServer(server_address, OTAHandler)
    logging.info("OTA server listening on port 8888")
    httpd.serve_forever()
```

**File: `/etc/systemd/system/guard-e-loo-ota.service`**
```ini
[Unit]
Description=Guard-e-loo OTA Server
After=network.target

[Service]
Type=simple
User=pi
WorkingDirectory=/home/pi/guard-e-loo/ota
ExecStart=/usr/bin/python3 /home/pi/guard-e-loo/ota/ota_server.py
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
```

### ESP32 OTA Client Code

**File: `esp32cam/CameraWebServer/ota.cpp`**
ESP32 HTTP OTA implementation:

```cpp
#include <Update.h>
#include <HTTPClient.h>
#include <WiFi.h>

#define OTA_SERVER "http://192.168.1.100:8888"
#define FIRMWARE_URL OTA_SERVER "/firmware.bin"
#define VERSION_URL OTA_SERVER "/version"

String currentFirmwareVersion = "v0.1.0";

bool checkForUpdate() {
  HTTPClient http;
  WiFiClient client;

  http.begin(client, VERSION_URL);
  int httpCode = http.GET();

  if (httpCode == 200) {
    String payload = http.getString();
    // Parse JSON: {"version": "v0.2.0", "size": 1048576}

    DynamicJsonDocument doc(256);
    deserializeJson(doc, payload);

    String availableVersion = doc["version"].as<String>();

    if (availableVersion != currentFirmwareVersion) {
      Serial.println("New firmware available: " + availableVersion);
      http.end();
      return true;
    }
  }

  http.end();
  return false;
}

bool performOTAUpdate() {
  HTTPClient http;
  WiFiClient client;

  http.begin(client, FIRMWARE_URL);
  int httpCode = http.GET();

  if (httpCode != 200) {
    Serial.println("OTA download failed");
    return false;
  }

  int contentLength = http.getSize();
  bool canBegin = Update.begin(contentLength);

  if (!canBegin) {
    Serial.println("Not enough space for OTA");
    return false;
  }

  Serial.println("Starting OTA update...");

  // Download and flash firmware
  WiFiClient *stream = http.getStreamPtr();
  size_t written = Update.writeStream(*stream);

  if (written == contentLength) {
    Serial.println("OTA update written successfully");
  } else {
    Serial.printf("OTA update failed: %d of %d bytes written\n", written, contentLength);
  }

  if (Update.end()) {
    if (Update.isFinished()) {
      Serial.println("OTA update complete, rebooting...");
      http.end();
      delay(1000);
      ESP.restart();
      return true;
    } else {
      Serial.println("OTA update not finished");
    }
  } else {
    Serial.printf("Error: %s\n", Update.errorString());
  }

  http.end();
  return false;
}

void setupOTA() {
  // Register OTA check endpoint
  server.on("/api/ota/check", HTTP_GET, [](AsyncWebServerRequest *request) {
    bool updateAvailable = checkForUpdate();
    request->send(200, "application/json",
                  "{\"update_available\":" + String(updateAvailable ? "true" : "false") + "}");
  });

  server.on("/api/ota/update", HTTP_POST, [](AsyncWebServerRequest *request) {
    bool success = performOTAUpdate();
    request->send(200, "application/json",
                  "{\"success\":" + String(success ? "true" : "false") + "}");
  });
}

// Check for updates every 6 hours
void periodicOTACheck() {
  static unsigned long lastCheck = 0;
  unsigned long now = millis();

  if (now - lastCheck > 6 * 60 * 60 * 1000) {  // 6 hours
    if (checkForUpdate()) {
      Serial.println("Initiating automatic OTA update");
      performOTAUpdate();
    }
    lastCheck = now;
  }
}
```

### Ansible OTA Deployment Playbook

**File: `ansible/playbooks/ota_deploy.yml`**
```yaml
---
- name: Deploy Firmware OTA to ESP32-CAM Devices
  hosts: pi_gateways
  vars:
    firmware_version: "{{ firmware_version }}"
    firmware_url: "https://firmware.guard-e-loo.co.uk/{{ firmware_version }}.bin"
    deployment_strategy: "{{ deployment_strategy | default('rolling') }}"

  tasks:
    - name: Download firmware to Pi gateway
      get_url:
        url: "{{ firmware_url }}"
        dest: "/home/pi/guard-e-loo/ota/firmware/{{ firmware_version }}.bin"
        mode: '0644'

    - name: Verify firmware checksum
      stat:
        path: "/home/pi/guard-e-loo/ota/firmware/{{ firmware_version }}.bin"
        checksum_algorithm: sha256
      register: firmware_stat

    - name: Update firmware manifest
      copy:
        content: |
          {
            "version": "{{ firmware_version }}",
            "size": {{ firmware_stat.stat.size }},
            "checksum": "{{ firmware_stat.stat.checksum }}",
            "deployed_at": "{{ ansible_date_time.iso8601 }}"
          }
        dest: /home/pi/guard-e-loo/ota/firmware/manifest.json

    - name: Symlink current firmware
      file:
        src: "/home/pi/guard-e-loo/ota/firmware/{{ firmware_version }}.bin"
        dest: /home/pi/guard-e-loo/ota/firmware/current.bin
        state: link

    - name: Get list of ESP32 devices
      uri:
        url: "http://localhost:5000/api/devices"
        method: GET
      register: devices

    - name: Trigger OTA update on each ESP32
      uri:
        url: "http://{{ item.ip }}/api/ota/update"
        method: POST
        timeout: 120
      loop: "{{ devices.json }}"
      when: deployment_strategy == 'immediate'

    - name: Rolling update strategy
      include_tasks: ota_rolling_update.yml
      loop: "{{ devices.json }}"
      when: deployment_strategy == 'rolling'

    - name: Verify all devices updated
      uri:
        url: "http://{{ item.ip }}/api/device/info"
        method: GET
      register: device_info
      loop: "{{ devices.json }}"
      until: device_info.json.firmware_version == firmware_version
      retries: 10
      delay: 30
```

**File: `ansible/playbooks/ota_rolling_update.yml`**
```yaml
---
# Rolling update: update one device, verify, then next
- name: Update device {{ item.device_id }}
  uri:
    url: "http://{{ item.ip }}/api/ota/update"
    method: POST
    timeout: 120

- name: Wait for device to reboot
  wait_for:
    host: "{{ item.ip }}"
    port: 80
    delay: 10
    timeout: 120

- name: Verify firmware version
  uri:
    url: "http://{{ item.ip }}/api/device/info"
    method: GET
  register: verify
  failed_when: verify.json.firmware_version != firmware_version

- name: Pause between updates
  pause:
    seconds: 30
```

### Firmware Version Tracking

**File: `ec2/firmware_cnc/firmware_manifest.json`**
```json
{
  "versions": [
    {
      "version": "v0.1.0",
      "release_date": "2025-11-01",
      "status": "stable",
      "notes": "Initial baseline release"
    },
    {
      "version": "v0.2.0",
      "release_date": "2025-11-15",
      "status": "testing",
      "notes": "Added motion detection"
    }
  ],
  "sites": {
    "site001": {
      "devices": [
        {"id": "ESP32-001", "ip": "192.168.1.50", "version": "v0.1.0"},
        {"id": "ESP32-002", "ip": "192.168.1.51", "version": "v0.1.0"}
      ]
    }
  }
}
```

## Acceptance Criteria

- [ ] **EC2 CNC Server**: Flask app for firmware management running
- [ ] **Firmware Upload**: Web UI to upload new firmware binaries
- [ ] **SSH Reverse Tunnel**: Persistent tunnel from Pi to EC2
- [ ] **Tunnel Auto-Restart**: Tunnel manager restarts on failure
- [ ] **Pi OTA Server**: HTTP server serving firmware to ESP32s
- [ ] **ESP32 OTA Client**: HTTP OTA implementation in firmware
- [ ] **Version Check**: ESP32 checks for updates via /version endpoint
- [ ] **Ansible Playbook**: ota_deploy.yml deploys to multiple sites
- [ ] **Rolling Updates**: Deploy to one device at a time with verification
- [ ] **Rollback Capability**: Revert to previous firmware on failure
- [ ] **Manifest Tracking**: Centralized firmware version database
- [ ] **Audit Logging**: Log all firmware deployments
- [ ] **Health Checks**: Verify device connectivity before update
- [ ] **Update Scheduling**: Deploy updates during low-traffic hours
- [ ] **Multi-Site Support**: Deploy to selective sites (not all at once)
- [ ] **Dashboard**: Web UI showing device firmware status

## Dependencies
- Story 1.3 (ESP32 baseline) - OTA client code
- Story 1.4 (Ansible) - Deployment orchestration
- EC2 instance with public IP
- Raspberry Pi gateways at each site
- SSH keys for Pi → EC2 authentication
- Flask, Ansible, Python 3.8+

## Notes

- SSH reverse tunnel allows EC2 to reach Pi behind NAT without port forwarding
- Each site gets unique remote port on EC2 (8080, 8081, 8082, etc.)
- OTA updates require sufficient flash partition space (3MB app + OTA partition)
- ESP32 reboots after successful OTA (brief camera downtime)
- Failed OTA automatically rolls back to previous firmware
- Consider rate limiting (update 10 devices per hour to avoid network saturation)
- Store firmware binaries on S3 for redundancy
- Test OTA on single device before mass deployment
- Monitor device reboot loops (indicates bad firmware)
- Keep at least 2 previous firmware versions for emergency rollback

````
