# Story 2.4: Multi-Sensor Coverage

**Epic:** 2 - Smart Privacy Detection
**Status:** ❌ TODO

## Description
Design and implement a multi-sensor coverage strategy that ensures reliable occupancy detection across entire facilities using multiple PIR sensors. This includes sensor placement optimization, redundancy for critical areas, sensor fusion for improved accuracy, and handling of edge cases like multiple stalls and sensor failures.

## Goals
- Achieve 99%+ occupancy detection accuracy
- Provide redundant coverage for single-point-of-failure elimination
- Support multiple stalls with independent sensor control
- Implement sensor fusion (combine multiple sensors for better decisions)
- Handle sensor failures gracefully (failsafe to privacy-safe state)
- Optimize sensor placement for cost-effectiveness

## Technical Implementation

### Sensor Coverage Patterns

**Single Stall Coverage:**
```
┌─────────────────────────┐
│    Toilet Stall         │
│                         │
│   [PIR-1]  ← Primary    │
│      ↓                  │
│   Detection Zone        │
│   (3-5m radius)         │
│                         │
│   [Toilet]              │
│                         │
└─────────────────────────┘
Camera: ESP32-CAM-001
PIR: PIR-001 → Stall-1
```

**Single Stall with Redundancy:**
```
┌─────────────────────────┐
│    Toilet Stall         │
│  [PIR-1]    [PIR-2]     │
│     ↓          ↓        │
│  Primary   Backup       │
│       ╲    ╱            │
│        Zone             │
│                         │
│      [Toilet]           │
│                         │
└─────────────────────────┘
Logic: OR (either sensor triggers disable)
```

**Multiple Stalls Shared Wall:**
```
┌─────────┬─────────┬─────────┐
│ Stall 1 │ Stall 2 │ Stall 3 │
│ [PIR-1] │ [PIR-2] │ [PIR-3] │
│    ↓    │    ↓    │    ↓    │
│  Zone1  │  Zone2  │  Zone3  │
│         │         │         │
│[Toilet1]│[Toilet2]│[Toilet3]│
└─────────┴─────────┴─────────┘
Camera Layout:
- CAM-1 covers Stall 1
- CAM-2 covers Stalls 2+3
- CAM-3 covers common area
```

**Large Facility (e.g., Train Station):**
```
┌──────────────────────────────────┐
│  Main Entrance                    │
│         [PIR-ENTRY]               │
│                                   │
│  ┌────┬────┬────┐  ┌────┬────┐  │
│  │ S1 │ S2 │ S3 │  │ S4 │ S5 │  │
│  │[P1]│[P2]│[P3]│  │[P4]│[P5]│  │
│  └────┴────┴────┘  └────┴────┘  │
│                                   │
│  [Urinal Area]                    │
│     [PIR-U1]  [PIR-U2]            │
│                                   │
│  [Sink Area]                      │
│     [PIR-SINK] (Optional)         │
└──────────────────────────────────┘
Coverage Zones:
- Entry: 1 sensor (early warning)
- Stalls 1-3: Individual sensors + CAM-1
- Stalls 4-5: Individual sensors + CAM-2
- Urinals: 2 sensors + CAM-3
- Sinks: Optional monitoring
```

### Sensor Fusion Logic

**File: `pi1/sensor_fusion.py`**

```python
from typing import Dict, List
import time
from enum import Enum

class SensorState(Enum):
    VACANT = 0
    OCCUPIED = 1
    UNKNOWN = 2
    FAILED = 3

class SensorFusion:
    def __init__(self, config: Dict):
        self.config = config
        self.zones = {}  # {zone_id: {sensors, cameras, state, last_update}}
        self.sensor_health = {}  # {sensor_id: {last_seen, failure_count}}

    def register_zone(self, zone_id: str, sensor_ids: List[str],
                     camera_ids: List[str], fusion_strategy: str = "OR"):
        """Register a coverage zone with multiple sensors"""
        self.zones[zone_id] = {
            'sensor_ids': sensor_ids,
            'camera_ids': camera_ids,
            'fusion_strategy': fusion_strategy,  # OR, AND, MAJORITY
            'state': SensorState.VACANT,
            'last_update': time.time(),
            'sensor_states': {sid: SensorState.VACANT for sid in sensor_ids}
        }

        for sensor_id in sensor_ids:
            self.sensor_health[sensor_id] = {
                'last_seen': time.time(),
                'failure_count': 0,
                'zone': zone_id
            }

    def update_sensor(self, sensor_id: str, occupied: bool) -> Dict:
        """Update sensor state and calculate zone occupancy"""
        # Update sensor health
        if sensor_id in self.sensor_health:
            self.sensor_health[sensor_id]['last_seen'] = time.time()
            self.sensor_health[sensor_id]['failure_count'] = 0

        # Find zone containing this sensor
        zone_id = None
        for zid, zone in self.zones.items():
            if sensor_id in zone['sensor_ids']:
                zone_id = zid
                break

        if not zone_id:
            return {'error': f'Sensor {sensor_id} not registered in any zone'}

        zone = self.zones[zone_id]

        # Update individual sensor state
        new_state = SensorState.OCCUPIED if occupied else SensorState.VACANT
        zone['sensor_states'][sensor_id] = new_state
        zone['last_update'] = time.time()

        # Calculate zone occupancy using fusion strategy
        old_zone_state = zone['state']
        new_zone_state = self._calculate_zone_state(zone)

        zone['state'] = new_zone_state

        # Return result with state change flag
        return {
            'zone_id': zone_id,
            'old_state': old_zone_state,
            'new_state': new_zone_state,
            'state_changed': old_zone_state != new_zone_state,
            'camera_ids': zone['camera_ids'],
            'sensor_states': zone['sensor_states']
        }

    def _calculate_zone_state(self, zone: Dict) -> SensorState:
        """Apply fusion strategy to determine zone state"""
        strategy = zone['fusion_strategy']
        sensor_states = list(zone['sensor_states'].values())

        # Check for failed sensors
        healthy_sensors = [s for s in sensor_states if s != SensorState.FAILED]
        if not healthy_sensors:
            return SensorState.UNKNOWN  # All sensors failed

        if strategy == "OR":
            # ANY sensor detecting = OCCUPIED (most conservative for privacy)
            return SensorState.OCCUPIED if any(s == SensorState.OCCUPIED for s in healthy_sensors) else SensorState.VACANT

        elif strategy == "AND":
            # ALL sensors must detect = OCCUPIED (less sensitive)
            return SensorState.OCCUPIED if all(s == SensorState.OCCUPIED for s in healthy_sensors) else SensorState.VACANT

        elif strategy == "MAJORITY":
            # Majority vote
            occupied_count = sum(1 for s in healthy_sensors if s == SensorState.OCCUPIED)
            return SensorState.OCCUPIED if occupied_count > len(healthy_sensors) / 2 else SensorState.VACANT

        return SensorState.UNKNOWN

    def check_sensor_health(self):
        """Detect and handle failed sensors"""
        current_time = time.time()
        timeout = self.config.get('sensor_timeout', 120)  # 2 minutes

        for sensor_id, health in self.sensor_health.items():
            time_since_seen = current_time - health['last_seen']

            if time_since_seen > timeout:
                # Sensor hasn't reported in 2 minutes - mark as failed
                zone_id = health['zone']
                if zone_id in self.zones:
                    zone = self.zones[zone_id]
                    zone['sensor_states'][sensor_id] = SensorState.FAILED

                    health['failure_count'] += 1

                    # Recalculate zone state
                    zone['state'] = self._calculate_zone_state(zone)

                    # If all sensors in zone failed, default to OCCUPIED (privacy-safe)
                    if zone['state'] == SensorState.UNKNOWN:
                        zone['state'] = SensorState.OCCUPIED
                        # Alert maintenance
                        self._send_alert(f"Zone {zone_id} all sensors failed - cameras disabled")

    def get_zone_status(self, zone_id: str = None) -> Dict:
        """Get status of one or all zones"""
        if zone_id:
            return self.zones.get(zone_id, {'error': 'Zone not found'})
        else:
            return self.zones

    def _send_alert(self, message: str):
        """Send alert to maintenance/operators"""
        # TODO: Implement alert system (email, SMS, webhook)
        print(f"ALERT: {message}")
```

### Sensor Placement Guidelines

**File: `docs/sensor_placement.md`**

```markdown
# PIR Sensor Placement Guidelines

## General Principles
1. **Height**: Mount 2-2.5m above floor (above door height)
2. **Angle**: Point downward at 15-30° angle toward occupant area
3. **Avoid**: Direct sunlight, heat sources (radiators, hand dryers), air vents
4. **Coverage**: 3-5m detection radius for HC-SR501

## Single Stall
- **1 Sensor (Basic)**: Mount above/beside door, facing toilet
- **2 Sensors (Recommended)**: Primary + backup for redundancy
  - Primary: Above door, facing toilet
  - Backup: Side wall, overlapping coverage
- **Fusion Strategy**: OR (either sensor triggers)

## Multiple Stalls
- **Individual Sensors**: 1 sensor per stall minimum
- **Shared Sensors**: 1 sensor per 2 stalls if budget constrained
- **Common Area**: 1 sensor monitoring entrance/sink area

## Large Facilities
- **Entry Detection**: 1-2 sensors at main entrance (early warning)
- **Zone Coverage**: Divide into logical zones (3-4 stalls per zone)
- **Critical Areas**: Accessible stalls get 2 sensors (redundancy)
- **Sink Area**: Optional monitoring for occupancy analytics

## Edge Cases
- **Accessible Stalls**: 2 sensors + longer timeout (Story 2.3)
- **Family Rooms**: 2+ sensors, longer timeout
- **High Traffic**: 2 sensors in OR mode for reliability
- **Outdoor Facilities**: Weather-resistant enclosures, heater for PIR

## Testing Procedure
1. Install sensor, power on
2. Wave hand in front at various distances (1m, 3m, 5m)
3. Test from multiple angles (direct, peripheral)
4. Verify coverage overlaps with adjacent sensors
5. Test for false positives (door opening, air movement)
6. 24-hour burn-in test
```

## Acceptance Criteria

- [ ] **Zone Registration**: System supports multiple zones with independent sensor arrays
- [ ] **Sensor Fusion**: OR, AND, MAJORITY strategies implemented and configurable
- [ ] **Redundancy**: Zones with 2+ sensors handle single sensor failure gracefully
- [ ] **Health Monitoring**: Failed sensors detected within 2 minutes
- [ ] **Failsafe Behavior**: Zone defaults to OCCUPIED state if all sensors fail
- [ ] **Alert System**: Maintenance notified when sensors fail
- [ ] **Configuration File**: Zone/sensor mappings defined in JSON config
- [ ] **Dashboard Visualization**: Sensor coverage map shows all zones and sensor states
- [ ] **Multi-Stall Support**: System manages 10+ independent stalls simultaneously
- [ ] **Placement Guidelines**: Documentation with diagrams for installers
- [ ] **Testing Protocol**: Sensor testing checklist and acceptance criteria
- [ ] **Coverage Map**: Physical layout diagrams for each installation site
- [ ] **Sensor Calibration**: Process for adjusting sensitivity per location
- [ ] **False Positive Handling**: Logic to ignore brief detections (<5 seconds)
- [ ] **Edge Case Support**: Accessible stalls, family rooms with appropriate settings
- [ ] **Performance**: System processes 50+ sensor updates/second without lag
- [ ] **State Persistence**: Sensor states persist across Pi restarts
- [ ] **API Endpoints**: `/api/zones`, `/api/sensors/health` for monitoring

## Dependencies
- Story 2.1 (PIR sensors) - hardware devices
- Story 2.2 (Camera control API) - actuator for sensor decisions
- Story 2.3 (Occupancy timers) - timeout management per zone
- Story 5.2 (Dashboard) - visualization of sensor coverage

## Notes
- OR fusion most conservative for privacy (any detection = disable cameras)
- AND fusion useful for reducing false positives in high-traffic areas
- MAJORITY useful for 3+ sensor arrays (voting mechanism)
- Consider using Bayesian sensor fusion for probabilistic occupancy (future)
- Test coverage with thermal imaging camera (verify PIR blind spots)
- Document installation photos for each site (reference for troubleshooting)
- Consider adding accelerometer to sensors (detect tampering/removal)
- Future: Computer vision to validate PIR detection (when privacy allows)
