# Story 2.3: Occupancy Timer System

**Epic:** 2 - Smart Privacy Detection
**Status:** âŒ TODO

## Description
Implement intelligent timer-based logic on the Raspberry Pi that automatically re-enables cameras after configurable timeout periods when no occupancy is detected. This prevents cameras from remaining disabled indefinitely if PIR sensors fail to detect departure, while maintaining privacy during use.

## Goals
- Auto-enable cameras after occupancy timeout (default: 5 minutes)
- Support configurable timeouts per location/stall
- Implement multiple timeout strategies (fixed, adaptive, time-of-day)
- Provide manual override capability for maintenance
- Log all timeout events for analysis
- Handle edge cases (sensor failures, stuck sensors, multiple occupants)

## Technical Implementation

### Timer Manager (Raspberry Pi)

**File: `pi1/occupancy_timer.py`**

```python
import time
import threading
from typing import Dict, Callable
from datetime import datetime, timedelta
import logging

class OccupancyTimer:
    def __init__(self, camera_controller, config: Dict):
        self.camera_controller = camera_controller
        self.config = config
        self.timers = {}  # {stall_id: {start_time, timeout, camera_ids, status}}
        self.lock = threading.Lock()
        self.logger = logging.getLogger(__name__)
        self.running = True

        # Start background timer thread
        self.timer_thread = threading.Thread(target=self._timer_loop, daemon=True)
        self.timer_thread.start()

    def start_occupancy(self, stall_id: str, camera_ids: list,
                       timeout_seconds: int = None):
        """Start occupancy timer for a stall"""
        with self.lock:
            # Get timeout from config or use default
            if timeout_seconds is None:
                timeout_seconds = self.config.get('default_timeout', 300)  # 5 min

            # Check for time-of-day overrides
            timeout_seconds = self._get_adaptive_timeout(stall_id, timeout_seconds)

            self.timers[stall_id] = {
                'start_time': time.time(),
                'timeout': timeout_seconds,
                'camera_ids': camera_ids,
                'status': 'occupied',
                'disable_count': self.timers.get(stall_id, {}).get('disable_count', 0) + 1
            }

            # Disable cameras
            for camera_id in camera_ids:
                self.camera_controller.disable_camera(
                    camera_id,
                    reason=f"occupancy_{stall_id}",
                    duration_seconds=timeout_seconds
                )

            self.logger.info(f"Stall {stall_id} occupied, timeout={timeout_seconds}s")

    def end_occupancy(self, stall_id: str):
        """End occupancy timer (PIR detected departure)"""
        with self.lock:
            if stall_id not in self.timers:
                return

            timer = self.timers[stall_id]
            duration = time.time() - timer['start_time']

            # Re-enable cameras immediately
            for camera_id in timer['camera_ids']:
                self.camera_controller.enable_camera(
                    camera_id,
                    reason=f"vacancy_detected_{stall_id}"
                )

            # Log occupancy duration
            self.logger.info(f"Stall {stall_id} vacated after {duration:.1f}s")
            self._log_occupancy_stats(stall_id, duration, 'sensor_detected')

            # Remove timer
            del self.timers[stall_id]

    def _timer_loop(self):
        """Background thread checking for timeouts"""
        while self.running:
            time.sleep(5)  # Check every 5 seconds

            with self.lock:
                current_time = time.time()
                expired_stalls = []

                for stall_id, timer in self.timers.items():
                    elapsed = current_time - timer['start_time']

                    if elapsed >= timer['timeout']:
                        expired_stalls.append(stall_id)

                # Process expired timers
                for stall_id in expired_stalls:
                    self._handle_timeout(stall_id)

    def _handle_timeout(self, stall_id: str):
        """Handle occupancy timeout"""
        timer = self.timers[stall_id]
        duration = time.time() - timer['start_time']

        # Re-enable cameras
        for camera_id in timer['camera_ids']:
            self.camera_controller.enable_camera(
                camera_id,
                reason=f"timeout_{stall_id}"
            )

        self.logger.warning(f"Stall {stall_id} timeout after {duration:.1f}s (expected {timer['timeout']}s)")
        self._log_occupancy_stats(stall_id, duration, 'timeout')

        # Check if this is a stuck sensor
        if timer['disable_count'] > 10:
            self.logger.error(f"Stall {stall_id} sensor may be stuck (10+ consecutive occupancies)")
            # TODO: Send alert to maintenance

        del self.timers[stall_id]

    def _get_adaptive_timeout(self, stall_id: str, default_timeout: int) -> int:
        """Calculate adaptive timeout based on time of day and historical data"""
        now = datetime.now()
        hour = now.hour

        # Night hours (10 PM - 6 AM): shorter timeout (assume less usage)
        if hour >= 22 or hour < 6:
            return min(default_timeout, 180)  # Max 3 minutes

        # Peak hours (8 AM - 10 AM, 12 PM - 2 PM): longer timeout
        if (8 <= hour < 10) or (12 <= hour < 14):
            return int(default_timeout * 1.5)  # 50% longer

        # Check historical average duration for this stall
        avg_duration = self._get_average_duration(stall_id)
        if avg_duration > 0:
            # Set timeout to 2x average, but within bounds
            adaptive = int(avg_duration * 2)
            return max(120, min(adaptive, 600))  # Between 2-10 minutes

        return default_timeout

    def _get_average_duration(self, stall_id: str) -> float:
        """Get average occupancy duration from stats (last 7 days)"""
        # TODO: Query from database
        # For now, return 0 (use default)
        return 0

    def _log_occupancy_stats(self, stall_id: str, duration: float, end_reason: str):
        """Log occupancy statistics for analysis"""
        stats = {
            'timestamp': datetime.now().isoformat(),
            'stall_id': stall_id,
            'duration': duration,
            'end_reason': end_reason,
            'hour': datetime.now().hour,
            'day_of_week': datetime.now().strftime('%A')
        }

        # Write to stats file/database
        # TODO: Store in database for analytics
        self.logger.info(f"Occupancy stats: {stats}")

    def get_status(self) -> Dict:
        """Get current timer status"""
        with self.lock:
            return {
                stall_id: {
                    'elapsed': time.time() - timer['start_time'],
                    'timeout': timer['timeout'],
                    'remaining': timer['timeout'] - (time.time() - timer['start_time']),
                    'status': timer['status']
                }
                for stall_id, timer in self.timers.items()
            }

    def extend_timeout(self, stall_id: str, additional_seconds: int):
        """Extend timeout for a stall (e.g., if PIR detects continued movement)"""
        with self.lock:
            if stall_id in self.timers:
                self.timers[stall_id]['timeout'] += additional_seconds
                self.logger.info(f"Extended timeout for {stall_id} by {additional_seconds}s")

    def force_enable(self, stall_id: str, reason: str = "manual_override"):
        """Manually end occupancy timer (maintenance/override)"""
        with self.lock:
            if stall_id in self.timers:
                timer = self.timers[stall_id]
                for camera_id in timer['camera_ids']:
                    self.camera_controller.enable_camera(camera_id, reason=reason)

                self.logger.warning(f"Force enabled stall {stall_id}: {reason}")
                del self.timers[stall_id]

    def shutdown(self):
        """Cleanup timers"""
        self.running = False
        self.timer_thread.join(timeout=5)
```

### Configuration File

**File: `pi1/config/occupancy_timers.json`**

```json
{
  "default_timeout": 300,
  "stalls": {
    "stall_1": {
      "timeout": 300,
      "camera_ids": ["ESP32-CAM-001"],
      "pir_sensor_id": "PIR-001"
    },
    "stall_2": {
      "timeout": 300,
      "camera_ids": ["ESP32-CAM-002"],
      "pir_sensor_id": "PIR-002"
    }
  },
  "time_of_day_rules": {
    "night": {
      "hours": [22, 23, 0, 1, 2, 3, 4, 5],
      "timeout": 180
    },
    "peak": {
      "hours": [8, 9, 12, 13],
      "timeout_multiplier": 1.5
    }
  },
  "stuck_sensor_threshold": 10,
  "enable_adaptive_timeout": true
}
```

## Acceptance Criteria

- [ ] **Basic Timer**: Cameras auto-enable after configured timeout (default 5 minutes)
- [ ] **Configurable Timeouts**: Different timeouts per stall/location via config file
- [ ] **PIR Override**: Timer cancelled immediately when PIR detects vacancy
- [ ] **Time-of-Day Rules**: Adaptive timeouts based on time of day (night vs peak)
- [ ] **Historical Learning**: Timeout adapts based on average occupancy duration
- [ ] **Status API**: `/api/timers/status` endpoint shows active timers and remaining time
- [ ] **Extend Timer**: PIR re-detection extends timeout (person still present)
- [ ] **Force Enable**: Manual override endpoint for maintenance access
- [ ] **Stats Logging**: All occupancy events logged with duration and end reason
- [ ] **Thread Safety**: Timer operations thread-safe with proper locking
- [ ] **Graceful Shutdown**: Cleanup timers on Pi shutdown/restart
- [ ] **Stuck Sensor Detection**: Alert when sensor triggers repeatedly (>10x)
- [ ] **Dashboard Integration**: Real-time timer status visible on web dashboard
- [ ] **Timeout Bounds**: Configurable min/max timeout limits (2-10 minutes)
- [ ] **Multiple Cameras**: Single timer controls multiple cameras in same area
- [ ] **Failure Recovery**: Timer continues after Pi restart (persisted state)
- [ ] **Performance**: Handles 20+ concurrent timers without degradation
- [ ] **Analytics**: Daily occupancy reports (average duration, peak hours, etc.)

## Dependencies
- Story 2.1 (PIR sensors) - triggers for timer start/stop
- Story 2.2 (Camera disable API) - camera control mechanism
- Story 5.2 (Dashboard) - timer status visualization
- Python threading and time libraries

## Notes
- Default 5-minute timeout balances privacy and operational efficiency
- Adaptive timeout reduces false positives (cameras staying disabled too long)
- Consider adding "grace period" - don't start timer for <10s occupancies (false triggers)
- Future: Machine learning to predict occupancy duration based on time/day patterns
- Timeout extension useful for accessible stalls (may need longer)
- Consider separate timeouts for different facility types (restaurant vs train station)
- Store stats in SQLite or PostgreSQL for historical analysis
