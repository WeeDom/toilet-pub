# Story 3.2: ESP32 ↔ Pi Communication

**Epic:** 3 - Device Communication Layer
**Status:** ❌ TODO

## Description
Implement HTTP client functionality on ESP32-CAM devices to enable proactive communication with Raspberry Pi controllers. This includes automatic registration on boot, periodic heartbeats, motion event reporting, and image upload capabilities.

## Goals
- ESP32 devices automatically register with Pi gateway on boot
- Implement reliable heartbeat mechanism (every 60 seconds)
- Enable motion event reporting from ESP32 to Pi
- Support image upload for motion events (when not privacy-locked)
- Handle network failures with retry logic and exponential backoff
- Minimize power consumption while maintaining responsiveness

## Technical Implementation

### ESP32 HTTP Client

**File: `esp32cam/CameraWebServer/pi_client.cpp`**

```cpp
#include <HTTPClient.h>
#include <WiFiClient.h>

String piGatewayIP = "192.168.1.100";  // Configured via mDNS or config
String authToken = "";
unsigned long lastHeartbeat = 0;
unsigned long lastMotionReport = 0;

// Auto-register with Pi on boot
void registerWithPi() {
  HTTPClient http;
  WiFiClient client;

  String url = "http://" + piGatewayIP + ":5000/api/devices/register";
  http.begin(client, url);
  http.addHeader("Content-Type", "application/json");

  StaticJsonDocument<512> doc;
  doc["device_id"] = WiFi.macAddress();
  doc["device_type"] = "esp32cam";
  doc["firmware_version"] = FIRMWARE_VERSION;
  doc["ip_address"] = WiFi.localIP().toString();
  doc["capabilities"] = serialized("[\"camera\",\"motion_detection\"]");

  String payload;
  serializeJson(doc, payload);

  int retries = 3;
  while (retries > 0) {
    int httpCode = http.POST(payload);

    if (httpCode == 200) {
      String response = http.getString();
      StaticJsonDocument<256> respDoc;
      deserializeJson(respDoc, response);

      authToken = respDoc["token"].as<String>();
      saveConfig("auth_token", authToken);

      Serial.println("Registered with Pi successfully");
      http.end();
      return;
    }

    retries--;
    delay(5000);  // Wait 5s before retry
  }

  Serial.println("Failed to register with Pi");
  http.end();
}

// Periodic heartbeat
void sendHeartbeat() {
  unsigned long now = millis();
  if (now - lastHeartbeat < 60000) return;  // Every 60 seconds

  HTTPClient http;
  WiFiClient client;

  String url = "http://" + piGatewayIP + ":5000/api/heartbeat";
  http.begin(client, url);
  http.addHeader("Content-Type", "application/json");
  http.addHeader("Authorization", "Bearer " + authToken);

  StaticJsonDocument<256> doc;
  doc["device_id"] = WiFi.macAddress();
  doc["uptime"] = millis() / 1000;
  doc["free_heap"] = ESP.getFreeHeap();
  doc["rssi"] = WiFi.RSSI();
  doc["camera_enabled"] = cameraEnabled;

  String payload;
  serializeJson(doc, payload);

  http.setTimeout(5000);
  int httpCode = http.POST(payload);

  if (httpCode == 200) {
    lastHeartbeat = now;
  }

  http.end();
}

// Report motion event
void reportMotionToPi(int motionScore) {
  if (millis() - lastMotionReport < 5000) return;  // Rate limit: 5 seconds

  HTTPClient http;
  WiFiClient client;

  String url = "http://" + piGatewayIP + ":5000/api/events/motion";
  http.begin(client, url);
  http.addHeader("Content-Type", "application/json");
  http.addHeader("Authorization", "Bearer " + authToken);

  StaticJsonDocument<256> doc;
  doc["device_id"] = WiFi.macAddress();
  doc["timestamp"] = time(nullptr);
  doc["motion_score"] = motionScore;
  doc["camera_enabled"] = cameraEnabled;

  String payload;
  serializeJson(doc, payload);

  http.setTimeout(3000);
  int httpCode = http.POST(payload);

  if (httpCode == 200) {
    lastMotionReport = millis();
    Serial.println("Motion reported to Pi");
  }

  http.end();
}

// Upload image (for motion events when cameras enabled)
bool uploadImageToPi(camera_fb_t * fb) {
  if (!cameraEnabled) return false;  // Privacy check

  HTTPClient http;
  WiFiClient client;

  String url = "http://" + piGatewayIP + ":5000/api/images/upload";
  http.begin(client, url);
  http.addHeader("Authorization", "Bearer " + authToken);
  http.addHeader("X-Device-ID", WiFi.macAddress());
  http.addHeader("Content-Type", "image/jpeg");

  http.setTimeout(30000);  // 30 seconds for image upload
  int httpCode = http.POST(fb->buf, fb->len);

  bool success = (httpCode == 200);
  http.end();

  return success;
}

// Call in main loop
void piClientLoop() {
  if (WiFi.status() != WL_CONNECTED) return;

  sendHeartbeat();
  checkForCommands();  // Poll for Pi commands (alternative to webhooks)
}
```

### Pi Server Endpoints

**File: `pi1/device_api.py`**

```python
from flask import Flask, request, jsonify
from datetime import datetime
import sqlite3

app = Flask(__name__)

@app.route('/api/devices/register', methods=['POST'])
def register_device():
    data = request.json
    device_id = data['device_id']

    # Store in database
    conn = sqlite3.connect('devices.db')
    c = conn.cursor()
    c.execute('''INSERT OR REPLACE INTO devices
                 (device_id, type, firmware, ip, last_seen)
                 VALUES (?, ?, ?, ?, ?)''',
              (device_id, data['device_type'], data['firmware_version'],
               data['ip_address'], datetime.now()))
    conn.commit()
    conn.close()

    # Generate auth token
    token = generate_token(device_id)

    return jsonify({'status': 'registered', 'token': token})

@app.route('/api/heartbeat', methods=['POST'])
def heartbeat():
    device_id = request.headers.get('X-Device-ID') or request.json.get('device_id')

    # Update last_seen
    conn = sqlite3.connect('devices.db')
    c = conn.cursor()
    c.execute('UPDATE devices SET last_seen = ? WHERE device_id = ?',
              (datetime.now(), device_id))
    conn.commit()
    conn.close()

    return jsonify({'status': 'ok'})

@app.route('/api/events/motion', methods=['POST'])
def motion_event():
    data = request.json
    device_id = data['device_id']
    motion_score = data['motion_score']

    # Log motion event
    log_event('motion', device_id, {'score': motion_score})

    # Trigger processing (if needed)
    handle_motion_event(device_id, motion_score)

    return jsonify({'status': 'received'})

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
```

## Acceptance Criteria

- [ ] **Auto-Registration**: ESP32 registers with Pi automatically on boot
- [ ] **Heartbeat**: ESP32 sends heartbeat every 60 seconds
- [ ] **Motion Reporting**: ESP32 reports motion events to Pi in real-time
- [ ] **Image Upload**: ESP32 uploads JPEG images to Pi (when privacy allows)
- [ ] **Retry Logic**: Exponential backoff on failed HTTP requests
- [ ] **Token Management**: ESP32 stores and uses auth token from Pi
- [ ] **Network Resilience**: Handles WiFi dropouts and reconnections
- [ ] **Rate Limiting**: Motion reports limited to 1 per 5 seconds
- [ ] **Timeout Handling**: HTTP requests timeout after 5-30 seconds
- [ ] **Error Logging**: Connection failures logged to SPIFFS
- [ ] **Pi API Endpoints**: /register, /heartbeat, /events/motion, /images/upload
- [ ] **Database Storage**: Pi stores device registry in SQLite
- [ ] **mDNS Discovery**: ESP32 can discover Pi via esp32cam.local (optional)
- [ ] **Command Polling**: ESP32 checks for Pi commands periodically
- [ ] **Integration Test**: Test lab validates full communication flow

## Dependencies
- Story 3.1 (ESP32 API) - API framework
- Story 2.2 (Camera control) - privacy checks
- Flask for Pi web server
- SQLite for device registry

## Notes
- Consider WebSocket for bidirectional real-time communication
- mDNS useful for dynamic Pi discovery on network
- Future: MQTT for pub/sub event model (more efficient)
