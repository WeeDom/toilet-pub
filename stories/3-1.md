# Story 3.1: ESP32 API Enhancement

**Epic:** 3 - Device Communication Layer
**Status:** ‚ùå TODO

## Description
Expand the ESP32-CAM firmware API beyond basic camera control to include motion event reporting, device registration, configuration management, and diagnostic endpoints. This creates a comprehensive REST API that enables full remote management and integration with the Pi controller.

## Goals
- Provide standardized RESTful API for all ESP32 operations
- Enable remote configuration without re-flashing firmware
- Support motion event reporting to Pi controller
- Implement device discovery and automatic registration
- Provide diagnostic and debugging endpoints
- Support firmware version reporting and OTA readiness checks

## Technical Implementation

### Enhanced API Endpoints

**File: `esp32cam/CameraWebServer/api.cpp`**

```cpp
#include "api.h"
#include <ArduinoJson.h>
#include <SPIFFS.h>

// ============ DEVICE MANAGEMENT ============

// POST /api/register
void handleRegister() {
  StaticJsonDocument<512> request;
  deserializeJson(request, server.arg("plain"));

  // Get Pi gateway info
  String piGatewayIP = request["pi_gateway_ip"];
  String siteID = request["site_id"];
  String token = request["token"];

  // Save to SPIFFS config
  saveConfig("pi_gateway", piGatewayIP);
  saveConfig("site_id", siteID);
  saveConfig("auth_token", token);

  // Respond with device info
  StaticJsonDocument<512> response;
  response["device_id"] = WiFi.macAddress();
  response["firmware_version"] = FIRMWARE_VERSION;
  response["chip_model"] = ESP.getChipModel();
  response["flash_size"] = ESP.getFlashChipSize();
  response["free_heap"] = ESP.getFreeHeap();
  response["uptime"] = millis() / 1000;
  response["ip_address"] = WiFi.localIP().toString();
  response["rssi"] = WiFi.RSSI();

  String responseStr;
  serializeJson(response, responseStr);
  server.send(200, "application/json", responseStr);
}

// GET /api/device/info
void handleDeviceInfo() {
  StaticJsonDocument<512> doc;

  doc["device_id"] = WiFi.macAddress();
  doc["firmware_version"] = FIRMWARE_VERSION;
  doc["build_date"] = __DATE__ " " __TIME__;
  doc["chip_model"] = ESP.getChipModel();
  doc["chip_revision"] = ESP.getChipRevision();
  doc["cpu_freq_mhz"] = ESP.getCpuFreqMHz();
  doc["flash_size"] = ESP.getFlashChipSize();
  doc["free_heap"] = ESP.getFreeHeap();
  doc["min_free_heap"] = ESP.getMinFreeHeap();
  doc["uptime_seconds"] = millis() / 1000;
  doc["reset_reason"] = ESP.getResetReason();

  // Network info
  JsonObject network = doc.createNestedObject("network");
  network["ip_address"] = WiFi.localIP().toString();
  network["mac_address"] = WiFi.macAddress();
  network["ssid"] = WiFi.SSID();
  network["rssi"] = WiFi.RSSI();
  network["channel"] = WiFi.channel();

  // Camera status
  JsonObject camera = doc.createNestedObject("camera");
  camera["enabled"] = cameraEnabled;
  camera["resolution"] = cameraResolution;
  camera["quality"] = cameraQuality;
  camera["fps"] = currentFPS;

  String response;
  serializeJson(doc, response);
  server.send(200, "application/json", response);
}

// ============ CONFIGURATION ============

// GET /api/config
void handleGetConfig() {
  if (!authenticate()) return;

  File file = SPIFFS.open("/config.json", "r");
  if (!file) {
    server.send(404, "application/json", "{\"error\":\"Config not found\"}");
    return;
  }

  String config = file.readString();
  file.close();
  server.send(200, "application/json", config);
}

// PUT /api/config
void handleSetConfig() {
  if (!authenticate()) return;

  StaticJsonDocument<1024> doc;
  deserializeJson(doc, server.arg("plain"));

  // Update config file
  File file = SPIFFS.open("/config.json", "w");
  serializeJson(doc, file);
  file.close();

  // Apply configuration
  if (doc.containsKey("camera")) {
    applyCamera Config(doc["camera"]);
  }
  if (doc.containsKey("motion")) {
    applyMotionConfig(doc["motion"]);
  }
  if (doc.containsKey("network")) {
    applyNetworkConfig(doc["network"]);
  }

  server.send(200, "application/json", "{\"status\":\"config updated\"}");
}

// ============ MOTION DETECTION ============

// POST /api/motion/config
void handleMotionConfig() {
  if (!authenticate()) return;

  StaticJsonDocument<256> doc;
  deserializeJson(doc, server.arg("plain"));

  motionEnabled = doc["enabled"].as<bool>();
  motionThreshold = doc["threshold"].as<int>();
  motionSensitivity = doc["sensitivity"].as<int>();
  motionReportInterval = doc["report_interval"].as<int>();

  saveConfig("motion_enabled", String(motionEnabled));
  saveConfig("motion_threshold", String(motionThreshold));

  server.send(200, "application/json", "{\"status\":\"motion config updated\"}");
}

// GET /api/motion/status
void handleMotionStatus() {
  StaticJsonDocument<256> doc;

  doc["enabled"] = motionEnabled;
  doc["threshold"] = motionThreshold;
  doc["sensitivity"] = motionSensitivity;
  doc["last_detection"] = lastMotionTime;
  doc["detection_count"] = motionDetectionCount;
  doc["current_score"] = currentMotionScore;

  String response;
  serializeJson(doc, response);
  server.send(200, "application/json", response);
}

// POST /api/motion/event
// Called internally when motion detected
void reportMotionEvent(int motionScore, unsigned long timestamp) {
  if (!motionEnabled) return;

  // Get Pi gateway IP from config
  String piGateway = loadConfig("pi_gateway");
  if (piGateway.length() == 0) return;

  HTTPClient http;
  WiFiClient client;

  String url = "http://" + piGateway + "/api/events/motion";
  http.begin(client, url);
  http.addHeader("Content-Type", "application/json");
  http.addHeader("Authorization", "Bearer " + loadConfig("auth_token"));

  StaticJsonDocument<256> doc;
  doc["device_id"] = WiFi.macAddress();
  doc["timestamp"] = timestamp;
  doc["motion_score"] = motionScore;
  doc["camera_enabled"] = cameraEnabled;

  String payload;
  serializeJson(doc, payload);

  int httpCode = http.POST(payload);
  if (httpCode > 0) {
    Serial.println("Motion event reported: " + String(httpCode));
  }
  http.end();
}

// ============ DIAGNOSTICS ============

// GET /api/diagnostics
void handleDiagnostics() {
  if (!authenticate()) return;

  StaticJsonDocument<1024> doc;

  // System diagnostics
  doc["timestamp"] = time(nullptr);
  doc["uptime"] = millis() / 1000;
  doc["free_heap"] = ESP.getFreeHeap();
  doc["min_free_heap"] = ESP.getMinFreeHeap();
  doc["heap_fragmentation"] = ESP.getHeapFragmentation();

  // Camera diagnostics
  JsonObject camera = doc.createNestedObject("camera");
  camera["initialized"] = cameraInitialized;
  camera["frame_count"] = totalFrames;
  camera["error_count"] = cameraErrors;
  camera["current_fps"] = currentFPS;
  camera["avg_frame_time_ms"] = avgFrameTime;

  // Network diagnostics
  JsonObject network = doc.createNestedObject("network");
  network["wifi_connected"] = WiFi.status() == WL_CONNECTED;
  network["rssi"] = WiFi.RSSI();
  network["reconnect_count"] = wifiReconnectCount;
  network["packets_sent"] = packetsSent;
  network["packets_failed"] = packetsFailed;

  // Storage diagnostics
  JsonObject storage = doc.createNestedObject("storage");
  storage["total_bytes"] = SPIFFS.totalBytes();
  storage["used_bytes"] = SPIFFS.usedBytes();
  storage["free_bytes"] = SPIFFS.totalBytes() - SPIFFS.usedBytes();

  String response;
  serializeJson(doc, response);
  server.send(200, "application/json", response);
}

// GET /api/logs
void handleGetLogs() {
  if (!authenticate()) return;

  File file = SPIFFS.open("/camera_log.txt", "r");
  if (!file) {
    server.send(404, "text/plain", "No logs found");
    return;
  }

  // Get last N lines (query param: ?lines=100)
  int maxLines = server.arg("lines").toInt();
  if (maxLines == 0) maxLines = 100;

  String logs = file.readString();
  file.close();

  server.send(200, "text/plain", logs);
}

// POST /api/reboot
void handleReboot() {
  if (!authenticate()) return;

  server.send(200, "application/json", "{\"status\":\"rebooting\"}");
  delay(1000);
  ESP.restart();
}

// ============ OTA READINESS ============

// GET /api/ota/check
void handleOTACheck() {
  StaticJsonDocument<256> doc;

  doc["current_version"] = FIRMWARE_VERSION;
  doc["ota_supported"] = true;
  doc["free_space"] = ESP.getFreeSketchSpace();
  doc["sketch_size"] = ESP.getSketchSize();
  doc["can_update"] = ESP.getFreeSketchSpace() > ESP.getSketchSize();

  String response;
  serializeJson(doc, response);
  server.send(200, "application/json", response);
}

// ============ HELPER FUNCTIONS ============

bool authenticate() {
  String authHeader = server.header("Authorization");
  String expectedToken = "Bearer " + loadConfig("auth_token");

  if (authHeader != expectedToken) {
    server.send(401, "application/json", "{\"error\":\"Unauthorized\"}");
    return false;
  }
  return true;
}

void saveConfig(String key, String value) {
  // TODO: Implement config persistence to SPIFFS
}

String loadConfig(String key) {
  // TODO: Implement config loading from SPIFFS
  return "";
}

// ============ SETUP ============

void setupAPIRoutes() {
  // Device management
  server.on("/api/register", HTTP_POST, handleRegister);
  server.on("/api/device/info", HTTP_GET, handleDeviceInfo);

  // Configuration
  server.on("/api/config", HTTP_GET, handleGetConfig);
  server.on("/api/config", HTTP_PUT, handleSetConfig);

  // Motion detection
  server.on("/api/motion/config", HTTP_POST, handleMotionConfig);
  server.on("/api/motion/status", HTTP_GET, handleMotionStatus);

  // Diagnostics
  server.on("/api/diagnostics", HTTP_GET, handleDiagnostics);
  server.on("/api/logs", HTTP_GET, handleGetLogs);
  server.on("/api/reboot", HTTP_POST, handleReboot);

  // OTA
  server.on("/api/ota/check", HTTP_GET, handleOTACheck);

  // From Story 2.2
  server.on("/api/camera/disable", HTTP_POST, handleDisable);
  server.on("/api/camera/enable", HTTP_POST, handleEnable);
  server.on("/api/heartbeat", HTTP_POST, handleHeartbeat);
  server.on("/api/status", HTTP_GET, handleStatus);
}
```

## Acceptance Criteria

- [ ] **Device Info Endpoint**: GET /api/device/info returns comprehensive device information
- [ ] **Registration**: POST /api/register saves Pi gateway configuration
- [ ] **Configuration Read**: GET /api/config returns current device configuration
- [ ] **Configuration Write**: PUT /api/config updates device settings without reboot
- [ ] **Motion Config**: POST /api/motion/config adjusts motion detection parameters
- [ ] **Motion Status**: GET /api/motion/status shows current motion detection state
- [ ] **Motion Reporting**: Device automatically reports motion events to Pi
- [ ] **Diagnostics**: GET /api/diagnostics provides system health metrics
- [ ] **Log Access**: GET /api/logs returns recent event logs
- [ ] **Remote Reboot**: POST /api/reboot safely restarts device
- [ ] **OTA Check**: GET /api/ota/check verifies update readiness
- [ ] **Authentication**: All sensitive endpoints require Bearer token
- [ ] **Error Handling**: Proper HTTP status codes for all error conditions
- [ ] **JSON Responses**: All endpoints return well-formed JSON
- [ ] **API Documentation**: OpenAPI/Swagger specification available
- [ ] **Response Times**: All endpoints respond within 500ms
- [ ] **Concurrent Requests**: Handles multiple API calls without crashing
- [ ] **Config Persistence**: Configuration survives device reboots

## Dependencies
- Story 1.3 (ESP32 baseline) - firmware foundation
- Story 2.2 (Camera control API) - camera management endpoints
- ArduinoJson library (v6+)
- SPIFFS for configuration storage

## Notes
- Store configuration in JSON format on SPIFFS for easy backup/restore
- Consider adding GET /api/camera/capture for single frame capture
- Future: WebSocket endpoint for real-time event streaming
- Add rate limiting to prevent API abuse
- Consider implementing CORS for web dashboard access
- Future: mDNS for device discovery (esp32cam-001.local)
