# Story 2.2: Camera Disable/Enable API

**Epic:** 2 - Smart Privacy Detection
**Status:** ‚ùå TODO

## Description
Implement HTTP API endpoints on ESP32-CAM devices that allow the Raspberry Pi controller to remotely enable and disable camera operation. This is the core privacy protection mechanism - when PIR sensors detect occupancy, the Pi sends disable commands to nearby cameras, ensuring no footage is captured while stalls are in use.

## Goals
- Provide instant camera control from Pi gateway (<500ms response)
- Ensure cameras cannot be activated while disabled (tamper-proof)
- Support both individual camera control and group operations
- Log all enable/disable events with timestamps
- Implement failsafe: cameras auto-disable on lost Pi connection
- Provide visual indication of camera state (LED)

## Technical Implementation

### ESP32-CAM API Endpoints

**Add to `CameraWebServer.ino`:**

```cpp
#include <ArduinoJson.h>

// Camera state management
bool cameraEnabled = true;
bool privacyLocked = false;
unsigned long privacyLockTime = 0;
unsigned long lastPiHeartbeat = 0;

#define HEARTBEAT_TIMEOUT 60000  // 60 seconds
#define PRIVACY_LOCK_DURATION 300000  // 5 minutes default

// API: GET /status
void handleStatus() {
  StaticJsonDocument<256> doc;
  doc["device_id"] = WiFi.macAddress();
  doc["camera_enabled"] = cameraEnabled;
  doc["privacy_locked"] = privacyLocked;
  doc["uptime"] = millis() / 1000;
  doc["firmware_version"] = FIRMWARE_VERSION;
  doc["last_heartbeat"] = (millis() - lastPiHeartbeat) / 1000;

  String response;
  serializeJson(doc, response);
  server.send(200, "application/json", response);
}

// API: POST /camera/disable
void handleDisable() {
  if (!server.hasArg("plain")) {
    server.send(400, "application/json", "{\"error\":\"No body\"}");
    return;
  }

  StaticJsonDocument<256> doc;
  DeserializationError error = deserializeJson(doc, server.arg("plain"));

  if (error) {
    server.send(400, "application/json", "{\"error\":\"Invalid JSON\"}");
    return;
  }

  // Check authentication token (from Story 6.5)
  if (!doc.containsKey("token") || !validateToken(doc["token"])) {
    server.send(401, "application/json", "{\"error\":\"Unauthorized\"}");
    return;
  }

  // Disable camera
  cameraEnabled = false;
  privacyLocked = true;
  privacyLockTime = millis();

  // Get lock duration (default 5 minutes)
  unsigned long duration = doc.containsKey("duration") ?
                          doc["duration"].as<unsigned long>() * 1000 :
                          PRIVACY_LOCK_DURATION;

  // Stop streaming if active
  stopCameraStream();

  // Turn off camera LED
  digitalWrite(LED_PIN, LOW);

  // Log event
  logEvent("CAMERA_DISABLED", doc["reason"].as<String>());

  StaticJsonDocument<128> response;
  response["status"] = "disabled";
  response["locked_until"] = (privacyLockTime + duration) / 1000;

  String responseStr;
  serializeJson(response, responseStr);
  server.send(200, "application/json", responseStr);
}

// API: POST /camera/enable
void handleEnable() {
  if (!server.hasArg("plain")) {
    server.send(400, "application/json", "{\"error\":\"No body\"}");
    return;
  }

  StaticJsonDocument<256> doc;
  DeserializationError error = deserializeJson(doc, server.arg("plain"));

  if (error) {
    server.send(400, "application/json", "{\"error\":\"Invalid JSON\"}");
    return;
  }

  // Check authentication
  if (!doc.containsKey("token") || !validateToken(doc["token"])) {
    server.send(401, "application/json", "{\"error\":\"Unauthorized\"}");
    return;
  }

  // Check if privacy lock has expired
  if (privacyLocked && (millis() - privacyLockTime < PRIVACY_LOCK_DURATION)) {
    unsigned long remaining = (PRIVACY_LOCK_DURATION - (millis() - privacyLockTime)) / 1000;

    StaticJsonDocument<128> response;
    response["status"] = "locked";
    response["remaining_seconds"] = remaining;

    String responseStr;
    serializeJson(response, responseStr);
    server.send(423, "application/json", responseStr);  // 423 Locked
    return;
  }

  // Enable camera
  cameraEnabled = true;
  privacyLocked = false;

  // Turn on camera LED
  digitalWrite(LED_PIN, HIGH);

  // Log event
  logEvent("CAMERA_ENABLED", doc["reason"].as<String>());

  StaticJsonDocument<128> response;
  response["status"] = "enabled";

  String responseStr;
  serializeJson(response, responseStr);
  server.send(200, "application/json", responseStr);
}

// API: POST /heartbeat
void handleHeartbeat() {
  lastPiHeartbeat = millis();

  StaticJsonDocument<128> doc;
  doc["status"] = "alive";
  doc["camera_enabled"] = cameraEnabled;

  String response;
  serializeJson(doc, response);
  server.send(200, "application/json", response);
}

// Check heartbeat timeout in main loop
void checkHeartbeat() {
  if (millis() - lastPiHeartbeat > HEARTBEAT_TIMEOUT) {
    // Lost connection to Pi - failsafe disable
    if (cameraEnabled) {
      cameraEnabled = false;
      logEvent("CAMERA_DISABLED", "Heartbeat timeout");
      digitalWrite(LED_PIN, LOW);
    }
  }
}

// Prevent streaming when disabled
void handleStream() {
  if (!cameraEnabled) {
    server.send(403, "text/plain", "Camera disabled for privacy");
    return;
  }

  // Existing stream handling code...
}

// Event logging to SPIFFS
void logEvent(String event, String reason) {
  File logFile = SPIFFS.open("/camera_log.txt", "a");
  if (logFile) {
    time_t now = time(nullptr);
    char timeStr[64];
    strftime(timeStr, sizeof(timeStr), "%Y-%m-%d %H:%M:%S", localtime(&now));

    logFile.printf("[%s] %s: %s\n", timeStr, event.c_str(), reason.c_str());
    logFile.close();
  }
}

// Setup API routes
void setupAPI() {
  server.on("/status", HTTP_GET, handleStatus);
  server.on("/camera/disable", HTTP_POST, handleDisable);
  server.on("/camera/enable", HTTP_POST, handleEnable);
  server.on("/heartbeat", HTTP_POST, handleHeartbeat);
  server.on("/logs", HTTP_GET, handleGetLogs);
}
```

### Raspberry Pi Client Library

**File: `pi1/camera_control.py`**

```python
import requests
import json
import time
from typing import List, Dict
import logging

class CameraController:
    def __init__(self, auth_token: str):
        self.auth_token = auth_token
        self.cameras = {}  # {device_id: {ip, status, last_seen}}
        self.logger = logging.getLogger(__name__)

    def register_camera(self, device_id: str, ip_address: str):
        """Register a camera with the controller"""
        self.cameras[device_id] = {
            'ip': ip_address,
            'status': 'unknown',
            'last_seen': time.time()
        }
        self.logger.info(f"Registered camera {device_id} at {ip_address}")

    def disable_camera(self, device_id: str, reason: str = "occupancy_detected",
                      duration_seconds: int = 300) -> bool:
        """Disable a specific camera"""
        if device_id not in self.cameras:
            self.logger.error(f"Camera {device_id} not registered")
            return False

        camera = self.cameras[device_id]
        url = f"http://{camera['ip']}/camera/disable"

        payload = {
            'token': self.auth_token,
            'reason': reason,
            'duration': duration_seconds
        }

        try:
            response = requests.post(url, json=payload, timeout=2)
            if response.status_code == 200:
                camera['status'] = 'disabled'
                self.logger.info(f"Camera {device_id} disabled: {reason}")
                return True
            else:
                self.logger.error(f"Failed to disable {device_id}: {response.text}")
                return False
        except requests.exceptions.RequestException as e:
            self.logger.error(f"Error disabling camera {device_id}: {e}")
            return False

    def enable_camera(self, device_id: str, reason: str = "vacancy_confirmed") -> bool:
        """Enable a specific camera"""
        if device_id not in self.cameras:
            self.logger.error(f"Camera {device_id} not registered")
            return False

        camera = self.cameras[device_id]
        url = f"http://{camera['ip']}/camera/enable"

        payload = {
            'token': self.auth_token,
            'reason': reason
        }

        try:
            response = requests.post(url, json=payload, timeout=2)
            if response.status_code == 200:
                camera['status'] = 'enabled'
                self.logger.info(f"Camera {device_id} enabled: {reason}")
                return True
            elif response.status_code == 423:  # Locked
                data = response.json()
                self.logger.warning(f"Camera {device_id} still locked: {data.get('remaining_seconds')}s remaining")
                return False
            else:
                self.logger.error(f"Failed to enable {device_id}: {response.text}")
                return False
        except requests.exceptions.RequestException as e:
            self.logger.error(f"Error enabling camera {device_id}: {e}")
            return False

    def disable_area(self, camera_ids: List[str], reason: str = "area_occupied") -> Dict[str, bool]:
        """Disable multiple cameras in an area"""
        results = {}
        for camera_id in camera_ids:
            results[camera_id] = self.disable_camera(camera_id, reason)
        return results

    def get_status(self, device_id: str) -> Dict:
        """Get current status of a camera"""
        if device_id not in self.cameras:
            return {'error': 'Camera not registered'}

        camera = self.cameras[device_id]
        url = f"http://{camera['ip']}/status"

        try:
            response = requests.get(url, timeout=2)
            if response.status_code == 200:
                status = response.json()
                camera['last_seen'] = time.time()
                camera['status'] = 'enabled' if status['camera_enabled'] else 'disabled'
                return status
            else:
                return {'error': f"HTTP {response.status_code}"}
        except requests.exceptions.RequestException as e:
            return {'error': str(e)}

    def heartbeat(self, device_id: str) -> bool:
        """Send heartbeat to camera"""
        if device_id not in self.cameras:
            return False

        camera = self.cameras[device_id]
        url = f"http://{camera['ip']}/heartbeat"

        try:
            response = requests.post(url, json={'token': self.auth_token}, timeout=2)
            if response.status_code == 200:
                camera['last_seen'] = time.time()
                return True
            return False
        except:
            return False

    def heartbeat_all(self):
        """Send heartbeat to all registered cameras"""
        for device_id in self.cameras.keys():
            self.heartbeat(device_id)
```

## Acceptance Criteria

- [ ] **HTTP Endpoints**: `/status`, `/camera/disable`, `/camera/enable`, `/heartbeat` implemented
- [ ] **Disable Function**: Camera stops streaming when disabled via API
- [ ] **Enable Function**: Camera resumes streaming when enabled via API
- [ ] **Privacy Lock**: Cameras cannot be enabled for configured duration after disable
- [ ] **Authentication**: All control endpoints require valid auth token
- [ ] **Response Time**: API responds within 500ms for control commands
- [ ] **JSON API**: All endpoints use JSON request/response format
- [ ] **Error Handling**: Proper HTTP status codes (400, 401, 403, 423, 500)
- [ ] **Event Logging**: All state changes logged to SPIFFS with timestamps
- [ ] **Visual Indicator**: LED reflects camera state (on=enabled, off=disabled)
- [ ] **Heartbeat Failsafe**: Camera auto-disables if Pi heartbeat stops (60s timeout)
- [ ] **Stream Protection**: `/stream` endpoint returns 403 when camera disabled
- [ ] **Python Client Library**: `CameraController` class works with all API endpoints
- [ ] **Bulk Operations**: `disable_area()` function disables multiple cameras
- [ ] **Status Polling**: Pi can query camera status via GET /status
- [ ] **Log Retrieval**: GET /logs endpoint returns event history
- [ ] **Persistent State**: Camera remembers disabled state after reboot (until timeout)
- [ ] **Documentation**: API specification in OpenAPI/Swagger format
- [ ] **Integration Test**: Pi successfully controls test lab ESP32-CAM
- [ ] **Performance**: System handles 10+ cameras with <1s latency

## Dependencies
- Story 1.3 (ESP32 baseline) - firmware foundation
- Story 2.1 (PIR sensors) - trigger for disable commands
- Story 3.1 (ESP32 API enhancement) - API framework
- Story 6.5 (authentication) - token validation
- ArduinoJson library for ESP32
- Python requests library for Pi

## Notes
- Consider adding `/camera/disable/emergency` endpoint for instant disable (bypasses all checks)
- Future: WebSocket for real-time state updates (avoid polling)
- Privacy lock duration configurable per site (council sites may require longer)
- Log rotation needed (SPIFFS limited to 1-2MB)
- Consider MQTT as alternative to HTTP (lower latency, persistent connections)
- Add `/camera/force-enable` with admin override for maintenance (Story 6.5)
